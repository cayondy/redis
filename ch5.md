
## 레디스와 캐시

#### 캐시
- 데이터의 원본보다 더 빠르고 효율적으로 액세스할 수 있는 임시 데이터 저장소

- 캐시가 효과적인 경우
	- 원본 데이터 저장소에서 원하는 데이터를 찾기 위해 검색하는 시간이 오래 걸리거나, 매번 계산을 통해 데이터를 가져와야 한다.
	- 캐시에서 데이터를 가져오는 것이 원본 데이터 저장소 데이터를 요청하는 것보다 빨라야 한다.
	- 캐시에 저장된 데이터는 잘 변하지 않는 데이터다.
	- 캐시에 저장된 데이터는 자주 검색되는 데이터다.

- 캐시의 장점
	- 애플리케이션 응답 속도를 줄일 수 있다.
	- 원본 데이터 저장소에서 데이터를 읽는 커넥션을 줄일 수 있다.
	- CPU와 메모리 등의 리소스 사용을 줄일 수 있다.
	- 중요한 데이터를 캐시에 올려두고 사용할 때, 원본 데이터 저장소에 일시적으로 접근할 수 없는 경우에 데이터를 가져올 수 있다.

#### 캐시로서의 레디스

- 레디스는 단순하게 키-값 형태로 저장하기 때문에 데이터를 저장하고 반환하는 것이 간단하다.
- 다양한 자료 구조를 제공하므로 애플리케이션에서 사용하던 자료 구조를 변환하는 과정없이 바로 저장할 수 있다.
- 레디스는 인메모리 저장소이기 때문에 데이터를 검색하고 반환하는 것이 빠르다.
- 레디스의 센티널 또는 클러스터 기능을 사용하면 마스터 노드의 장애를 자동으로 감지해 페일오버를 발생시키기 때문에 운영자의 개입 없이 정상적인 캐시를 유지할 수 있다. -> 고가용성
- 캐시의 규모를 키워야할 때 클러스터를 사용하면 수평 확장이 간단해진다.


#### 캐싱 전략
- 캐싱되는 데이터의 유형과 데이터에 대한 액세스 패턴별 적절한 캐싱 전략을 선택해야 한다.

- 읽기 전략 - look aside
	- 애플리케이션에서 데이터를 읽어갈 때 주로 사용하며 레디스를 캐시로 사용할 때 가장 일반적으로 배치하는 방법
	- 캐시 히트
		- 애플리케이션이 찾고자 하는 데이터가 먼저 캐시에 있는지 확인한 뒤, 캐시에 있으면 캐시에서 데이터를 읽어온다.
	- 캐시 미스
		- 찾고자 하는 데이터가 캐시에 없을 때 발생
		- 직접 데이터베이스에 접근해 데이터를 가져온 뒤에 이를 캐시에 저장한다.
	- look aside 구조의 장점
		- 레디스에 접근하지 못하는 상황에도 바로 서비스 장애가 일어나지 않는다.
		- 하지만 기존에 레디스를 통해 데이터를 가져오는 연결이 매우 많았다면 원본 데이터 베이스에 부하가 몰려 성능에 영향을 미칠 수 있다.
	- lazy loading
		- 찾고자 하는 데이터가 없을 때만 레디스에 저장된다.
	
	- 사용 중인 서비스에 처음 레디스를 투입한다면?
		- 레디스에 접근할 때마다 캐시 미스가 발생
		- 캐시 워밍을 활용
			- 캐시 워밍: 미리 데이터베이스에서 캐시로 데이터를 밀어넣어주는 작업


- 쓰기 전략과 캐시의 일관성
	- 캐시는 저장된 데이터의 복사본이기 때문에 원본 데이터와 동일한 값을 갖도록 유지하는 것이 필수적이다.
	- 캐시 불일치
		- 데이터가 변경될 때 원본 데이터베이스에만 업데이트돼 캐시에는 변경된 값이 반영되지 않을 때의 현상

1. write through
 -  데이터베이스를 업데이트 할 때마다 캐시에도 데이터를 함께 업데이트 시키는 방식
 - 항상 최신 데이터를 가지고 있을 수 있지만 시간이 많이 소요된다.
 - 다시 사용하지 않을 데이터를 저장하게 되면 리소스 낭비이므로 데이터 저장 시 만료시간 사용을 권장한다.
 
1. cache invalidation
- 데이터베이스에 값을 업데이트할 때마다 캐시에서는 데이터를 삭제하는 전략
- 새로운 데이터를 저장하는 것보다 특정 데이터를 삭제하는 것이 리소스를 적게 사용하기 때문

1. write behind(write back)
- 쓰기가 빈번하게 발생하는 서비스에서 고려해볼 수 있다.
- 데이터를 빠르게 접근할 수 있는 캐시에 업데이트한 뒤, 건수나 특정 시간 간격 등 기준에 따라 비동기적으로 데이터베이스에 업데이트하는 방식
- 데이터가 실시간으로 업데이트되지 않아도 되는 경우 유용하다.
- 캐시에 문제가 생겨 데이터가 날아가는 경우 최대 5분 동안의 데이터가 날아갈 수 있다.



## 캐시에서의 데이터 흐름

- 캐시는 사용자가 자주 사용할 만한 데이터를 갖고 와서 임시로 저장하는 저장소
- 데이터 스토어보다 적은 양을 보관하는 데이터베이스의 서브셋(부분집합)으로 볼 수 있음
- 레디스는 메모리에 모든 데이터를 저장하므로 서버의 스토리지보다 훨씬 적은 양을 보관할 수 밖에 없다.
- 일정 양의 데이터를 유지하며 새로운 데이터가 저장되고 기존 데이터는 삭제될 수 있도록 관리돼야 한다. -> 데이터 저장 시 만료 시간 지정

#### 만료 시간
- 만료 시간 (TTL)은 데이터가 얼마나 오래 저장될 것인지를 나타내는 시간 설정
- 레디스는 데이터베이스 특정 키에 대한 만료 시간을 설정할 수 있으며, 데이터의 유효 기간 또는 만료 시간을 정의하는 데 사용된다.
- 일반적으로 초 단위로 표현된다.

```
// a = 100 저장
> SET a 100
"OK"

// 만료 시간 60초 설정
> EXPIRE a 60
(integer) 1

// 남은 만료 시간 확인
// -2: 키가 존재하지 않음
// -1: 만료시간이 지정되지 않음
> TTL a
(integer) 58
```

- INCR 커맨드로 데이터를 조작하거나 RENAME 으로 키의 이름을 바꾸더라도 설정된 만료 시간은 변경되지 않음

```
> SET b 100
"OK"

> EXPIRE b 60
(integer) 1

> TTL b
(integer) 58

// 기존 키에 새로운 값 저장(덮어씀)
> SET b banana
"OK"

// 만료 시간 설정 사라짐
> TTL b
(integer) -1
```

> - 레디스에서 키가 만료됐다고 해도 바로 삭제되는 것은 아니다.
> - passive 방식과 active 방식 두 가지로 삭제된다.
> - passive 방식: 클라이언트가 키에 접근하고자 할  때 키가 만료됐다면 메모리에서 수동적으로 삭제
> - active 방식: 
> 	- TTL 값이 있는 키 중 20개를 랜덤하게 뽑아낸 뒤, 만료된 키를 모두 삭제
> 	- 만약 25% 이상의 키가 삭제 됐다면 다시 20개의 키를 뽑아 확인하고 아니라면 뽑아놓은 키 집합에서 다시 확인한다.
> 	- 위 과정을 1초에 10번씩 수행한다.
> 	- 위 조건은 레디스에서 기본값으로 설정되어 있음
> - 만료된 키를 바로 삭제하지 않기 때문에 키를 삭제 하는 데에 드는 리소스르 줄일 수 있지만 그만큼 메모리를 더 사용할 수도 있다. 
> - 최악의 경우 전체 메모리의 1/4는 이미 만료된 키 값일 수 있다.


#### 메모리 관리와 maxmemory-policy 설정

- maxmemory: 최대 저장 용량을 설정
- maxmemory-policy: maxmemory를 초과할 때의 처리 방식을 결정   

- Noeviction - 기본값
	- 레디스에 데이터가 가득 차더라도 임의로 데이터를 삭제하지 않고 더이상 레디스에 저장할 수 없다는 에러를 반환
	- 하지만 캐시에 저장하지 못해 에러가 발생할 경우 로직에 따라 장애 상황으로 이어질 수 있다.
	- 위 상황 시에는 관리자가 직접 레디스의 데이터를 삭제해야한다. -> 권장하지 않음
	- 데이터를 애플리케이션 측에서 관리하겠다는 의미로 캐시 내부적 판단으로 데이터를 삭제하는 것이 위험하다고 판단될 때 사용

- LRU eviction (Least-Recently Used)
	- 가장 최근에 사용되지 않은 데이터부터 삭제하는 정책
	- 최근 액세스되지 않은 데이터는 나중에도 액세스될 가능성이 낮을 거라는 가정을 전제한다.
	- 캐시는 나중에 사용될 가능성이 있는 데이터를 유지하는 것을 목표로 하기 때문에 효율적인 메모리 관리 방법이다.
	- LRU 알고리즘 설정값
		- volatile-lru
			- 만료시간이 설정되어 있는 키에 한해서 LRU 방식으로 키를 삭제한다.
			- 임의적인 방식으로 삭제되면 안 되는 값에 대해 만료 시간을 지정하지 않는다면 이 방법이 적합
			- 저장된 키에 모두 만료 시간이 지정되어 있지 않다면 삭제할 수 있는 키가 하나도 없어서 에러를 반환할 수 있다. -> Noeviction 처럼 동작
		- allkeys-LRU
			- 레디스 공식 문서에서 레디스를 캐시로 사용할 경우 잘 모르겠다면 allkeys-LRU 방식을 사용하기를 권장한다.
			- 모든 키에 대해 LRU 알고리즘을 이용해 데이터를 삭제하기 때문에 적어도 메모리가 꽉찼을 때 장애가 발생할 상황은 방지할 수 있다.

- LFU eviction (Least-Frequently Used)
	- 가장 사용되지 않는 데이터부터 삭제하는 정책
	- 자주 사용되지 않는 데이터는 나중에도 액세스될 가능성이 낮을 것이라는 가정을 전제
	- LRU와 유사하지만 키를 액세스하는 패턴에 따라 우선순위가 유동적으로 바뀐다는 점에서 특정 케이스에는 LRU보다 효과적일 수 있다.
	- LFU 알고리즘 설정값
		- volatile-lfu
			- 만료 시간이 설정된 키에 한해 LFU 방식으로 삭제
			- volatile-lru와 동일하게 특정 상황에서는 장애를 유발할 가능성이 존재
		- allkeys-lfu
			- 모든 키에 대해 LFU 방식으로 삭제


- RANDOM eviction
	- 레디스에 저장된 키 중 하나를 임의로 골라내 삭제
	- 삭제될 키 값을 계산하지 않아도 된다는 점에서 레디스의 부하를 줄여줄 수 있는 방법이다.
	- 하지만 레디스는 근사 알고리즘을 사용하기 때문에 LRU, LFU 데이터를 찾는 데에 큰 리소스를 사용하지 않으므로 부하를 줄이기 위한 이유로 이 방법을 사용하는 것은 권장하지 않음
	- 설정값
		- volatile-random
			- 만료 시간이 설정된 키에 한해 랜덤하게 삭제
		- allkeys-random
			- 모든 키에 대해 랜덤하게 삭제



- volatile-ttl
	- 만료 시간이 가장 작은 키를 삭제
	- 삭제 예정 시간이 얼마 남지 않은 키를 추출해 해당 키를 미리 삭제하는 옵션
	- 마찬가지로 근사 알고리즘을 이용해 모든 키의 만료 시간을 비교하지 않고 키를 찾는다.



#### 캐시 스탬피드 현상

- 여러 개의 애플리케이션에서 바라보던 키가 레디스에서 만료돼 삭제된다면 이 서버들은 한꺼번에 데이터베이스로 가서 데이터를 읽어오는 과정을 거치게 되고 이를 **중복 읽기**라 한다.
- 이후에 각 애플리케이션에서는 읽어온 데이터를 레디스에 쓰게 되는데 이것도 반복되기 때문에 **중복 쓰기**가 발생한다.
- 한번 캐시 스탬피드 현상이 발생하면 결과적으로 더 많은 데이터가 영향을 받게 되어 더 큰 문제로 이어질 수 있다. -> 계단식 실패 현상


- 캐시 스탬피드를 줄이기 위한 방법
	- 적절한 만료시간을 설정
	- 선 계산
		- 캐시 스탬피드가 문제되는 이유는 데이터가 만료되는 시점에 여러 애플리케이션에서 동시다발적으로 이를 인지하고 작업을 동시에 진행하기 때문이다.
		- 키가 실제로 만료되기 전에 이 값을 미리 갱신해준다면 불필요한 프로세스를 줄일 수 있다.
		- 단순하게 데이터를 가져오는 방법보다 더 많은 리소스를 사용한다고 볼 수도 있지만 상황에 따라 캐시 스탬피드 현상을 줄일 수도 있다.
		- expiry_gap 값을 적절히 설정해주는 것이 중요하다.
	```
	// look aside 방식처럼 동작
	fun fetch(key: String): String? {
	    var value = redis.get(key)
	
	    if (value == null) {
	        value = db.fetch(key)
	        redis.set(key, value)
	    }
	
	    return value
	}

	// 실제로 만료되기 전 랜덤으로 데이터베이스에 접근해서 데이터를 읽어와 캐시의 값을 갱신
	fun fetchWithExpiryGap(key: String, expiryGap: Int): String? {
	    val ttl = redis.ttl(key) // Redis에 남은 TTL을 초 단위로 가져옴
	
	    // TTL이 아직 충분하고, 무작위 값보다 크면 캐시 반환
	    if (ttl > (Random.nextDouble() * expiryGap)) {
	        return redis.get(key)
	    } else {
	        val value = db.fetch(key)
	        redis.setex(key, KEY_TTL, value) // TTL과 함께 저장
	        return value
	    }
	}
	```


	- PER 알고리즘 (probabilistic Early Recomputation)
		- 캐시 스탬피드 현상을 완화시킬 수 있는 확률적 조기 재계산 알고리즘
			- currentTime: 현재 남은 만료 시간
			- timeToCompute: 캐시된 값을 다시 계산하는 데 걸리는 시간
			- beta: 기본적으로 1. 0보다 큰값으로 설정 가능
			- rand(): 0과 1 사이의 랜덤값 반환 함수
			- expiry: 키를 재설정할 때 새로 넣어줄 만료 시간
  
		```
		currentTime - (timeToCompute * beta * log(rand())) > expiry
		```
		
		- currentTime에서 무작위 값을 뺀 값이 expire 보다 작다면 조건이 참이 된다.
		- 만료 시간이 가까워지면 currentTime 과 expire차이가 작아지며 rand() 함수가 반환한 무작위 값에 의존하기 때문에 조건이 참이 될 확률이 높아진다.
		- 만료 시간이 점점 다가올 때 더 자주 만료된 캐시 항목을 확인하게 된다!<br/>
		
		- 위 조건문에서 true를 반환하는 애플리케이션은 데이터를 다시 계산하기 위해 데이터베이스로 이동하게 된다.
		- 만료 시간이 가까워질수록 true를 반환하는 확률이 높아지므로 불필요한 재계산을 효과적으로 방지하는 방법일 수 있다.
		- 따라서 데이터를 가져오는 과정에서 GET 대신 이 함수를 사용하면 성능을 최적화 하는 데 도움이 된다.


## 세션 스토어로서의 레디스

#### 세션이란?
- 서비스를 사용하는 클라이언트의 상태 정보를 의미한다.
- 애플리케이션은 현재 서비스에 로그인돼 있는 클라이언트가 누구인지, 어떤 활동을 하고 있는지 저장하고 있으며 서비스를 떠나면 세션 스토어에서 삭제한다.


#### 세션 스토어가 필요한 이유

- 서비스가 확장되어 웹서버를 늘리면 여러 개의 웹 서버에 트래픽을 분배할 수 있어 더 많은 유저를 수용할 수 있게 된다.
- 각 웹서버 별로 세션 스토어를 따로 관리한다면 유저는 유저의 세션 정보를 갖고 있는 웹 서버에 종속되어야 한다. -> 데이터 정합성 유지
- 특정 웹 서버에 유저가 몰려 트래픽이 집중되는 상황이 발생하면 유저는 다른 서버를 이용할 수 없어 트래픽을 분산시킬 수 없다. -> sticky session 현상
- 이런 경우 유저의 세션 정보를 모든 웹 서버에 복제해서 저장하는 방법이 있다. -> all-to-all 방법<br/>

- all-to-all 방법의 단점
	- 하나의 유저는 한 번에 하나의 웹 서버에만 접속하기 때문에 다른 웹 서버에 저장된 유저의 세션 정보는 무의미하다.
	- 데이터를 복제하는 과정에서 불필요한 네트워크 트래픽이 발생한다.

- 데이터베이스를 세션 스토어로 활용한다면?
	- 각 유저는 세션이 활성화돼 있는 동안 세션 스토어에 활발하게 액세스한다.
	- 세션 스토어의 응답이 느려지면 클라이언트의 응답 속도 저하로 이어질 수 있다.
	- 서비스가 커져 유저가 많아질수록 서비스의 전반적은 응답 속도를 저하시키는 요인이 될 수 있다.

- 레디스를 세션 스토어로 활용한다면?
	- 위 문제들을 해결 가능
	- 유저는 세션 스토어에 구애받지 않고 어떤 웹 서버에 연결되더라고 동일한 세션 데이터를 조회 가능
	- 효율적인 트래픽 분산
	- 데이터의 일관성 유지
	- 데이터베이스보다 빠르고 접근이 간편하므로 데이터를 가볍게 저장할 수 있다.

	```
	// hash 자료 구조를 이용한 세션 데이터 저장
	> HMSET usersession:1 Name Garimoo IP 10:20:104:30 Hits 1
	OK
	> HINCRBY usersession:1 Hits 1
	(integer) 2
	```


#### 캐시와 세션의 차이

- 캐시와 세션은 비슷해 보이지만 데이터를 읽고 쓰는 패턴에 있어 약간의 차이점을 갖는다.
- 캐시
	- 데이터베이스의 완벽한 서브셋으로 데이터가 유실되더라도 해당 데이터는 데이터베이스에서 찾을 수 있다.
	- 캐시에 저장된 데이터는 여러 애플리케이션에서 함께 사용할 수 있다.
	- 여러 애플리케이션에서 활용될 수록 효율적이다.
- 세션
	- 세션 스토어에 저장된 데이터는 여러 사용자 간 공유되지 않으며, 특정 사용자ID에 한해 유효하다.
	- 유저가 로그인하면 세션 데이터는 세션 스토어에 저장된다.
	- 세션이 활성화돼 있는 동안에는 애플리케이션은 유저의 데이터를 데이터베이스가 아닌 세션 스토어에만 저장한다.
	- 유저가 로그아웃할 때 세션은 종료되며 이 때 데이터의 종류에 따라 데이터베이스에 저장해 보관할 것인지 삭제할 것인지 결정된다.
	- 세션 스토어에 장애가 발생하면 내부 데이터가 손실될 가능성이 있다.
- 레디스를 세션 스토어로 활용할 때에는 레디스를 캐시로 사용할 때보다 더 신중한 운영이 필요하다.
