# 06. 레디스를 메시지 브로커로 사용하기

#### 메시지 브로커가 필요한 이유

모듈간 상호 작용을 위한 효율적인 메시징 솔루션의 필요
통신 상황의 영향을 덜 받기 위해 동기 통신 횟수를 줄이고 비동기 통신을 권장
메시지를 어딘가에 쌓아둔 뒤 나중에 처리할 수 있는 채널을 만들어 줌


## 메시징 큐와 이벤트 스트림

- 메시징 큐
	- 생산자: 데이터를 생성하는 쪽
	- 소비자: 데이터를 수신하는 쪽
	- 생산자는 소비자의 큐로 데이터를 직접 push
	- 소비자가 데이터를 읽어가면 큐에서 삭제
	- 새롭게 추가된 소비자는 추가된 이후의 이벤트만 확인 가능
	- 일대일 상황에서 유리
	
- 이벤트 스트림
	- 발행자: 데이터를 생성하는 쪽
	- 구독자: 데이터를 조회하는 쪽
	- 발행자가 스트림의 특정 저장소에 보낸 메세지를 소비자가 pull 해감
	- 구독자가 읽어간 데이터를 설정한 기간동안 저장 가능
	- 새로 추가된 서비스도 스트림에 남은 이전 데이터 히스토리를 볼 수 있음
	- 다대다 상황에서 유리


#### 레디스를 메시지 브로커로 사용하기

- 발행자가 특정 채널에 데이터를 전송하면 채널의 모든 소비자는 데이터를 바로 소비 가능
- pub/sub에서 모든 데이터는 한 번 전파된 뒤 삭제되는 일회성의 특징을 가지며 메세지의 전달 여부 등의 정보는 보장하지 않음
- 따라서 완벽하게 메세지가 전달돼야하는 상황에는 부적합
- fire-and-forgot 패턴이 필요한 간단한 알림 서비스에 유용

>  **fire-and-forgot** 패턴
>  - 비동기 프로그래밍에서 사용되는 디자인 패턴
>  - 작업을 실행하고 결과 응답을 기다리지 않고 다음 코드를 실행함
>  - 신뢰성이 필요한 경우에는 부적합

- 메세징 큐로 알맞은 list 자료 구조
	- 레디스의 list 데이터는 푸시와 팝이 가능
	- list에 데이터가 있는지 매번 확인할 필요 없이 대기하다가 새로운 데이터가 들어오면 읽어갈 수 있는 블로킹 기능 사용 가능

- 레디스를 스트림 플랫폼으로 사용 가능한 stream 자료 구조
	- 레디스의 stream은 아파치 카프카 시스템의 영향을 받아 만들어진 자료 구조
	- 데이터가 계속 추가되는 방식으로 저장 (append-only)
	- 소비자와 소비자 그룹이라는 개념으로 카프카와 비슷한 데이터 분산 처리 구현이 가능
	- stream에 저장되는 메시지를 실시간으로 리스닝하며 소비 가능
	- 저장되어 있는 데이터를 시간대별로 검색 가능


## 레디스의 pub/sub

- 레디스 노드에 접근할 수 있는 모든 클라이언트는 발행자와 구독자가 될 수 있다.
- 레디스에서 pub/sub은 **최소한의 메시지 전달 기능만 제공**
- 발행자는 메세지 전송에 관련한 세부 내용을 알 수 없음
- 구독자도 메세지 정보에 관한 메타데이터를 알 수 없음
- 한 번 전파된 데이터는 레디스에 저장되지 않고 단순히 메시지 통로 역할만 한다.

#### 메시지 publish하기

- PUBLISH : 데이터 전파
```
// hello 채널을 수신하고 있는 모든 서버들에게 world 메시지 전파
// 메세지를 수신한 구독자의 수를 반환
> PUBLISH hello world
(integer) 1
```

#### 메시지 구독하기

- SUBSCRIBE: 특정 채널 구독
```
// event1 과 event2 채널을 동시에 구독
> SUBSCRIBE event1 event2
1) "subscribe"
2) "event1"
3) (integer) 1
4) "subscribe"
5) "event2"
6) (integer) 2
Reading messages... (press Ctrl-C to quit or any key to type command)
```

- 클라이언트가 구독자로 동작할 때는 새로운 채널을 구독할 수는 있지만 pub/sub과 관련되지 않은 다른 커맨드를 수행할 수는 없음
- 구독자가 수행할 수 있는 커맨드

| 커맨드            | 설명                      |
| -------------- | ----------------------- |
| `SUBSCRIBE`    | 하나 이상의 채널을 구독 (일반적인 구독) |
| `PSUBSCRIBE`   | 패턴 기반으로 여러 채널을 구독       |
| `UNSUBSCRIBE`  | 현재 구독 중인 채널 구독 해제       |
| `PUNSUBSCRIBE` | 패턴 구독 해제                |

```
// 앞부분이 mail- 로 시작하는 모든 채널에 전파된 메시지를 모두 수신
> PSUBSCRIBE mail-*
1) "psubscribe"
2) "mail-*"
3) (integer) 1
Reading messages... (press Ctrl-C to quit or any key to type command)
```

- SUBSCRIBE 와 마찬가지로 동시에 여러 문자열 구독 가능
- 메시지가 message 타입이 아닌 pmessage 타입으로 전달됨
- SUBSCRIBE 커맨드로 구독한 방식과 구분 가능
- SUBSCRIBE 와 PSUBSCRIBE로 같은 채널을 구독할 때 2개의 메시지를 받게 된다.


#### 클러스터 구조에서의 pub/sub

- 레디스 클러스터에서 pub/sub을 사용할 때, 메시지를 발행하면 해당 메시지는 클러스터에 속한 모든 노드에 자동으로 전달된다.
- 따라서 레디스 클러스터의 아무 노드에 연결해 SUBSCRIBE 커맨드를 사용하면 데이터를 수신할 수 있다.
- 하나의 노드에 메시지를 발행하면 메시지는 모든 노드에 전파된다.
- 하지만 클러스터는 대규모 서비스에서 데이터를 분산해서 저장하고 처리하기 위해 도입 됐으므로 주요 목적과는 맞지 않는 방식이다.

#### shared pub/sub

- 위에서 설명한 비효율을 해결하기 위한 기능
- shared pub/sub 환경에서 각 채널은 슬롯에 매핑
- 같은 슬롯을 가지고 있는 노드 간에만 pub/sub 메시지를 전파
- 불필요한 복제를 줄여 자원을 절약할 수 있다.

- SPUBLISH: 모든 노드에 전파되지 않고 노드의 복제본에만 전달
- SSUBSCRIBE: 특정 서버에서만 수행
```
// 아래 메시지와 함께 연결된 노드로 리다이렉트
> SPUBLISH apple a
-> Redirected to slot [7092] located at 10.0.0.1:6379
(integer) 0

// apple 채널은 apple 키 값을 할당 받을 수 있는 슬롯을 포함한 마스터 노드에 연결될 수 있도록 리다이렉트
> SSUBSCRIBE apple
-> Redirected to slot [7092] located at 10.0.0.1:6379
1) "ssubscribe"
2) "apple"
3) (integer) 1
4) "smessage"
5) "apple"
6) "a"
```

## 레디스의 list를 메시징 큐로 사용하기

- list는 큐로 사용하기 적절한 자료 구조이다.
- tail과 head 에서 데이터를 넣고 뺄 수 있으므로 커맨드를 활용해서 애플리케이션 특성에 맞는 메시징 큐를 직접 구현할 수 있다.

#### list의 EX 기능

- RPUSHX: 데이터를 저장하고자 하는 list가 이미 존재할 때만 아이템을 추가

```
// 캐시된 타임라인 데이터에는 데이터 추가됨
>  RPUSHX Timelinecache:userB data3
(integer) 26

> RPUSHX Timelinecache:userC data3
(integer) 5

// 데이터 추가 안됨
> RPUSHX Timelinecache:userD data3
(integer) 0
```
 - 사용자 캐시의 존재 여부를 확인하는 과정 없이 모든 로직을 레디스에서 제어할 수 있기 때문에 성능을 향상시킬 수 있다.

#### list의 블로킹 기능

- 레디스를 이벤트 큐로 사용할 경우 유용하다.

> 폴링 (poling)
> - 이벤트 루프는 이벤트 큐에 새 이벤트가 있는지 체크하고, 새로운 이벤트가 없을 경우 정해진 시간동안 대기한 뒤 다시 이벤트 큐에 데이터가 있는지 확인하는 과정을 반복한다. 
> - 이벤트 기반 구조에서 폴링 프로세스가 진행되는 동안 어플리케이션과 큐의 리소스가 불필요하게 소모될 수 있다.
>- 폴링 인터벌 시간 동안 대기한 뒤 다시 확인하는 시간을 거치므로 이벤트를 즉시 처리할 수 없다.

- BRPOP, BLPOP : 각각 RPOP와 LPOP에 블로킹을 추가한 커맨드
- 클라이언트가 BLPOP을 사용해 데이터를 요청했을 때 list 데이터가 있으면 즉시 반환한다.
- 만약 데이터가 없을 경우에는 list에 데이터가 들어올 때까지 기다린 후에 들어온 값을 반환하거나, 클라이언트가 설정한 타임아웃시간만큼 대기한 후에 nil값을 반환한다.
```
// 타임아웃 값이 0이면 데이터가 들어올 때까지 대기
> BRPOP queue:a 5
1) "queue:a" // 팝된 리스트 키값
2) "data" // 데이터값

> BRPOP queue:a 5
(nil)
(5.08s)
```


```
// 동시에 여러 개의 리스트에서 대기 가능
> BRPOP queue:a queue:b queue:c timeout 1000
1) "queue:b"
2) "DATA"
```
