# 07. 레디스 데이터 백업 방법

## 레디스에서 데이터를 영구 저장하기

- 장애 상황으로 인해 메모리에 상주해 있던 레디스의 모든 데이터는 손실된 가능성이 있다.
- 레디스를 복제 구조로 사용하는 경우에도 데이터 백업이 필요한 이유?
	- 복제는 가용성을 위한 것이고, 백업은 장애 상황에서 데이터의 복구를 위해 필요하다.
	- 마스터 노드에서 의도하지 않은 데이터를 삭제하는 커맨드가 실행되면 복제본에도 전달된다.
	- 따라서 복제 구조만으로는 데이터를 안전하게 유지할 수 없다.
- 레디스를 캐시가 아닌 영구 저장소와 같은 용도로 사용한다면 디스크에 주기적으로 백업하는 것이 안전하다.

#### 레디스가 지원하는 백업 방식

- AOF (Append Only File) : 레디스 인스턴스가 처리한 모든 쓰기 작업을 차례대로 기록. 복원 시에는 파일을 다시 읽어가며 데이터 세트 재구성
- RDB (Redis DataBase) : 일정 시점에 메모리에 저장된 데이터 전체를 저장

```
127.0.0.1:6379> SET key1 a
OK

127.0.0.1:6379> SET key1 apple
OK

127.0.0.1:6379> SET key2 b
OK

127.0.0.1:6379> DEL key2
(integer) 1
```

| 항목         | AOF                                                    | RDB             |
| ---------- | ------------------------------------------------------ | --------------- |
| 저장 방식      | 모든 쓰기 명령어 기록                                           | 메모리 스냅샷 저장      |
| 복구 시점      | 원하는 시점으로 복구 가능                                         | 특정 시점으로의 복구는 불가 |
| 데이터 유실 가능성 | 거의 없음                                                  | 최근 데이터 유실 가능    |
| 복구 방식      | 명령어 재실행                                                | 메모리 상태 복원       |
| 저장 내용      | SET key1 a<br>SET key1 apple<br>SET key2 b<br>DEL key2 | key1 -> apple   |
| 파일 형태      | 레디스 프로토콜                                               | 바이너리 형태         |
- 하나의 인스턴스에서 두 가지 옵션을 모두 사용하는 것도 가능
- 일반적인 RDB 만큼의 안정성을 원하는 경우 두 가지 백업 방식을 동시에 사용하는 것을 권장
- 레디스에서 데이터를 복원할 수 있는 시점은 서버가 재시작될 때이며, 레디스 인스턴스 실행 도중에 데이터 파일을 읽어올 수 있는 방법은 없다.
- 레디스는 AOF 파일을 더 안전하다고 판단해 RDB파일과 AOF 파일이 모두 존재하는 경우 AOF의 데이터를 로드한다.

> 레디스에서 AOF 파일이 더 내구성이 보장된다고 판단하는데
>  RDB 방식의 스냅샷이 데이터의 안정성을 유지하는데 유리하다?
>  
>  RDB 방식은 주기적으로 스냅샷을 저장하고 다음 스냅샷을 저장하기 전까지의 데이터는 유실될 수 있는데 왜 데이터의 안정성과 관련이 있을까?
>  
>  AOF는 파일을 연속적으로 수정한다. 따라서 예기치 못한 디스크 문제나 전원이 꺼질 경우 파일이 손상될 가능성이 있다.
>  
>  RDB는 메모리 전체를 스냅샷으로 저장하고 파일을 새로 생성한 후 교체하는 방식으로 파일 자체의 일관성은 높다.
>  
>  그래서 AOF(데이터 유실 최소) + RDB(파일 안정성 증가) 방식이 안정적이라고 할 수 있다.

## RDB 방식의 데이터 백업

- 레디스에서 데이터를 백업하기 위한 가장 단순한 방법
- 원하는 시점에 메모리 자체를 스냅샷 찍듯 저장하므로 백업에 적합한 파일 형태
- 일정한 주기로 RDB 파일을 생성하고 장애 발생 시 원하는 시점으로 데이터를 복원
- RDB 파일이 저장될 때마다 원격 저장소로 파일을 옮겨 2차 백업을 수행한다면 데이터 센터 장애 등 더 큰 장애에도 대처할 수 있다.
- 하지만 손실 가능성을 최소화해야하는 서비스에는 저장 시점 이후의 데이터는 손실될 수 있다는 점을 고려해야한다.
- RDB 파일을 생성할 수 있는 방법
	1) 설정 파일에서 특정 조건에 파일이 자동으로 저장되도록 지정
	2) 사용자가 원하는 시점에 커맨드를 이용해 수동으로 파일 생성
	3) 복제 기능으로 자동으로 생성

#### 특정 조건에 자동으로 RDB 파일 생성
```
save <기간(초)> <기간 내 변경된 키의 개수>
dbfilename <RDB 파일 이름>
dir <RDB 파일이 저장될 경로>
```

- save 옵션을 이용해 원하는 조건에 파일을 저장하도록 설정
- RDB 파일은 dbfilename 옵션에 지정된 이름으로 생성
	- 기본값은 dump.rdb

```
# save 조건 터미널에서 직접 설정
127.0.0.1:6379> CONFIG SET save "900 1 300 10 60 10000"
OK

# 현재 적용된 save 옵션 확인
127.0.0.1:6379> CONFIG GET save
1) "save"
2) "900 1 300 10 60 10000"

# save 옵션 초기화
127.0.0.1:6379> CONFIG SET save ""
OK

# 현재 적용된 save 옵션 확인
127.0.0.1:6379> CONFIG GET save
1) "save"
2) ""

# redis.conf 파일 재작성
127.0.0.1:6379> CONFIG REWRITE
OK
```

> CONFIG REWRITE
> 레디스 인스턴스가 실행 중인 상태에서 설정 파일을 변경하는 것은 레디스 인스턴스에는 반영되지 않으므로 redis-cli 에서 직접 CONFIG SET 커맨드로 설정을 변경한 뒤, CONFIG REWRITE 로 설정 파일을 재작성하는 과정을 거친다.
> 파일을 재작성하지 않은 상태로 레디스 인스턴스가 재시작되면 변경되지 않은 기존 설정파일 옵션으로 설정된다.

#### 수동으로 RDB 파일 생성

- SAVE
	- 동기 방식으로 파일을 저장
	- 커맨드를 실행하면 파일 생성이 완료될 때까지 다른 모든 클라이언트의 명령을 차단
	- 따라서 일반적인 운영 환경에서는 되도록 사용하지 않는 게 좋음
- BGSAVE
	- fork를 호출해 자식 프로세스를 생성하며 생성된 자식 프로세스가 백그라운드에서 RDB 파일을 생성한 뒤 종료
	- 다른 클라이언트는 부모 프로세스를 이용해 처리
	- 이미 백그라운드로 데이터가 저장 중일 때 실행하면 에러
	- SCHEDULE 옵션과 함께 사용해서 이미 파일이 백그라운드에서 저장 중일 때 일단 OK를 반환하고 백업이 완료됐을 때 다시 BGSAVE를 실행하도록 할 수 있다.
- LASTSAVE
	- RDB 파일이 정상적으로 저장됐는 지 확인
	- 마지막으로 RDB 파일이 저장된 시점을 유닉스 타임스탬프로 반환

#### 복제를 사용할 경우 자동으로 RDB 파일 생성

- 복제본에서 REPLICAOF 커맨드로 복제를 요청하면 마스터 노드에서는 RDB 파일을 새로 생성해 복제본으로 전달한다.
- 복제 연결이 돼 있는 상태에서 일정 시간 이상 복제가 끊어졌다가 복구된 경우 복구 재연결이 발생하며, 이 경우에도 마스터 노드에서 복제본으로 RDB 파일을 전송한다.
- 따라서 복제 연결을 처음 시작하거나 이미 연결돼 있는 상태에서도 마스터에서는 언제든지 RDB 파일을 재생성할 수 있다.

## AOF 방식의 데이터 백업

- AOF는 레디스 인스턴스에서 수행된 모든 쓰기 작업의 로그를 차례로 기록한다.
- 실수로 FLUSHALL 커맨드로 데이터를 모두 날려버렸다고 해도, AOF 파일을 직접 열어 FLUSHALL 커맨드만 삭제한 뒤 레디스를 재시작하면 커맨드 실행 직전까지 데이터를 바로 복구할 수 있다.
- 설정 파일에서 appendonly 옵션을 yes 로 지정하면 AOF 파일에 주기적으로 데이터가 저장된다.
- AOF 파일은 appendfilename 옵션으로 이름을 설정하고 appenddirname 옵션에 지정한 경로에 생성된다.

```
appendonly yes
appendfilename "appendonly.aof"
appenddirname "appendonlydir"
```

- appendfilename : 이 옵션으로 파일명을 변경하지 않으면 기본적으로 appendonly.aof 라는 이름으로 저장
- appenddirname: 옵션에서 지정된 디렉토리 하위에 저장되고 경로가 아닌 디렉터리 이름만 지정할 수 있다. dir 옵션 하위에 생성된다.

```
# 1
127.0.0.1:6379> SET key1 apple
OK
# 2
127.0.0.1:6379> SET key2 beer
OK
# 3
127.0.0.1:6379> DEL key1
(integer) 1
# 4
127.0.0.1:6379> DEL non_existing_key
(integer) 0
```

- 1~3 커맨드는 레디스 서버의 메모리에 영향을 끼치는 작업이고
- 4번 째 커맨드는 존재하지 않는 키를 삭제하는 작업으로 메모리가 수정되는 작업은 아니다.
- AOF 파일에는 메모리상의 데이터가 변경되는 작업만 기록된다.
- AOF에서 모든 커맨드의 실행 내역은 다음과 같이 레디스 프로토콜 형식으로 저장된다.
```
*3
$3
set
$4
key1
$5
apple
*3
$3
set
$4
key1
$4
beer
*2
$3
del
$4
key1
```

- 하지만 항상 AOF 파일이 사용자가 실행한 커맨드를 그대로 저장하는 것은 아니다.
- 예를 들어 list에서 블로킹 기능을 지원하는 BRPOP 커맨드는 AOF 파일에 저장될 때 블로킹 기능을 굳이 명시할 필요가 없기 때문에 RPOP으로 기록된다.

```
127.0.0.1:6379> RPUSH mylist a b c d e
(integer) 5

127.0.0.1:6379> BRPOP mylist 1
1) "mylist"
2) "e"
```

-  위 커맨드가 실행됐을 때 AOF 파일에 다음과 같이 저장
```
*7
$5
RPUSH
$6
mylist
$1
a
$1
b
$1
c
$1
d
$1
e
*2
$4
RPOP
$6
mylist
```

- 기존 string 값에 사용자가 입력한 부동소수점 값을 더해주는 INCRBYFLOAT 커맨드도 AOF 파일에는 그대로 기록되지 않는다.
```
127.0.0.1:6379> SET counter 100
OK

127.0.0.1:6379> INCRBYFLOAT counter 50
"150"
```

- 레디스가 실행되는 아키텍처에 따라 부동소수점을 처리하는 방식이 다를 수 있기 때문에 AOF 파일에는 증분 후의 값을 직접 SET하는 커맨드로 변경돼 저장된다.

```
*3
$3
SET
$7
counter
$3
100
*4
$3
SET
$7
counter
$3
150
$7
KEEPTTL
```

- AOF는 Append-Only File 이라는 이름 뜻 그대로 실행되는 커맨드가 파일의 뒤쪽에 계속 추가되는 방식으로 동작한다.
- 따라서 인스턴스가 실행되는 시간에 비례해서 파일의 크기는 계속 증가한다.
- INCR 커맨드를 사용해 counter 키를 100번 증가시킨다면 실제 레디스의 메모리에서는 증가된 값을 저장하고 있지만 AOF 파일에는 키를 증가시킨 100번의 실행 내역이 그대로 남아 있게 된다.


#### AOF 파일을 재구성하는 방법

- AOF 파일을 이용한 백업 기능을 안정적으로 사용하려면 점점 커지는 파일을 주기적으로 압축시키는 재구성 작업이 필요하다.
- RDB에서와 마찬가지로 특정 조건에 자동으로 재구성되도록 설정할 수도 있으며, 원하는 시점에 커맨드를 이용해 재구성시킬 수 있다.
- 재구성은 기존 디스크에 저장됐던 AOF 파일을 사용하는 것이 아니라 레디스 메모리에 있는 데이터를 읽어와서 새로운 파일로 저장하는 형태로 동작한다.
- 설정 파일에서 기본 옵션 aof-use-rdb-preamble yes를 no로 변경하지 않으면 데이터는 RDB 파일 형태로 저장한다.
- RDB와 마찬가지로 AOF 파일을 재구성할 때도 fork를 이용해 자식 프로세스를 생성하며, 이 자식 프로세스가 AOF 파일을 재구성해 저장한다.
- 버전 7 이전의 AOF
	- 하나의 파일로 관리
	- 파일의 앞부분은 RDB, 이후 변경 내용은 RESP 형태로 RDB 파일 뒤에 쌓이는 형태로 증가 
	> RESP - REdis Serialization Protocol
	> Redis 클라이언트와 서버가 명령어를 주고받을 때 사용하는 통신 규약

- 버전 7 이전의 AOF 재구성 과정
	1) fork를 이용해 자식 프로세스 생성 후, 레디스 메모리의 데이터를 읽어와 신규로 생성한 임시 파일에 저장
	2) 백그라운드로 과정1이 진행되는 동안 레디스 메모리의 변경 내역은 기존의 AOF 파일과 인메모리 버퍼에 동시에 저장
	3) 과정1의 AOF 재구성이 끝나면 인메모리 버퍼에 저장된 내용을 1의 임시 파일 마지막에 추가
	4) 생성된 임시 파일로 기존 AOF 파일을 덮어씌움
	- 하나의 AOF 파일 내에 바이너리 형태와 RESP의 텍스트 형태의 데이터가 함께 저장돼 관리가 복잡해질 수 있음

- 버전 7 이후의 AOF
	- AOF의 기본이 되는 바이너리 형태의 RDB 파일, 증가하는 RESP의 텍스트 형태의 AOF 파일로 나눠서 데이터를 관리
	- 현재 레디스가 바라보고 있는 파일이 어떤 건지 나타내는 매니페스트 파일 추가
	- 매니페스트 파일은 RDB 와 AOF 파일이 어떤 것인지 알려주는 역할
	- 세 파일은 모두 설정 파일에 지정한 appenddirname 이름의 폴더 내에 저장
	- AOF가 재구성 될 때마다 AOF를 구성하고 있는 각 RDB와 AOF의 파일명의 번호, 매니페스트 파일 내부의 seq 값도 1씩 증가한다.

-  버전 7 이후의 AOF 재구성 과정
	1) 레디스 인스턴스는 fork를 이용해 자식 프로세스 생성 후, 레디스 메모리의 데이터를 읽어와 신규로 생성한 임시 파일에 저장
	2) 백그라운드로 1이 진행되는 동안 레디스 메모리의 데이터가 변경된 내역은 신규 AOF 파일에 저장
	3) 1의 재구성 과정이 끝나면 임시 ㅁ매니페스트 파일을 생성한 뒤, 변경된 버전으로 매니페스트 파일 내용을 업데이트
	4) 생성된 임시 매니페스트 파일로 기존 매니페스트 파일을 덮어 씌운 뒤, 이전 버전의 AOF, RDB 파일을 삭제
	- 기존 버전의 2,3 단계의 비효율을 줄일 수 있다.

- aof-use-rdb-preamble 옵션을 no로 변경한다면 베이스 파일은 ~.base.aof 라는 이름으로 저장되며, 저장되는 형태도 RESP 프로토콜 형태의 텍스트로 변경된다.
- 레디스에서 AOF 파일의 재구성 과정은 모두 순차 입출력만 사용하기 때문에 디스크에 접근하는 모든 과정이 아주 효율적이다.
- 레디스 서버는 복원 시 순차적으로 데이터를 로드하는 용도로 AOF 파일을 사용
	- 파일 내에서 직접 데이터를 검색할 필요가 없기 때문에 랜덤 입출력을 고려할 이유가 X
	- RDB 파일 저장 시에도 동일
	- 이점은 모든 데이터 저장소에서 굉장히 드문 기능!
#### 자동 AOF 재구성

```
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

- auto-aof-rewrite-percentage
	- AOF 파일을 다시 쓰기 위한 시점을 지정하는 옵션
	- 마지막으로 재구성됐던 AOF 파일의 크기와 비교해 현재의 AOF 파일이 지정된 퍼센트만큼 커졌을 때 재구성을 시도
- 마지막으로 저장된 AOF 파일의 크기
	- INFO Persistance 커맨드로 확인 가능한 aof_base_size 값

```
> INFO Persistance
# Persistance
...
aof_current_size:180000
aof_base_size:140000
...
```

- 예제 설명
	- aof_base_size는 140000이고, aof_current_size는 180000일 때 auto-aof-rewrite-percentage가 100이면
	- aof_current_size 가 aof_base_size의 100% 만큼 커진 280000가 되면 자동으로 재구성을 시도한다.
- 데이터가 아무것도 없는 상태로 인스턴스가 처음 부팅됐을 때의 aof_base_size는 0이므로, 이때는 auto-aof-rewrite-min-size 를 기준으로 데이터를 재구성
- auto-aof-rewrite-min-size
	- 재구성된 이후의 AOF 파일의 최소 크기를 지정하는 옵션
	- 마지막으로 작성된 AOF 파일 크기를 기준으로 하되, 적어도 AOF이 특정 크기 이상일 때만 재구성하도록 지정함

#### 수동 AOF 재구성

- BGREWRITEOF 커맨드를 이용하면 원하는 시점에 직접 AOF 파일을 재구성할 수 있다.
- 자동으로 재구성할 때와 동일하게 동작한다.

#### AOF 타임스탬프

- 버전 7 이상 부터는 AOF를 저장할 때 타임스탬프를 남길 수 있다.
```
// yes: 타임스탬프 활성화 
// no: 비활성화 
aof-timestamp-enable no
```

- 활성화 시켰을 때
```
#TS:1669532240
*2
$6
SELECT
...
#TS:1669532845
...
```
- 수동으로 AOF 파일을 조작하지 않아도 시스템상에서 시점 복원이 가능하다.
- redis-check-aof 
	- 프로그램으로 원하는 타임스탬프를 입력해 해당 타임스탬프 이전까지의 데이터로 복구할 수 있다.
	- truncate-to-timestamp 옵션을 사용해 AOF 파일을 복구하면 원본 파일이 변경된다. 이전 AOF 파일을 보호하고 싶다면 원본 파일을 미리 다른 곳에 복사해두는 것이 좋다.

#### AOF 파일 복원

- 시점 복원에 사용한 redis-check-aof 프로그램은 AOF 파일이 손상됐을 때도 사용 가능하다.
```
$ src/redis-check-aof appendonlydir/appendonly.aof.manifest
Starting Checking Multi Part AOF
...
AOF appendonly.aof.15.incr.aof is not valid. Use the --fix option to try fixing it.
```

- 레디스가 의도치 않은 장애로 중단됐을 때 파일의 상태가 정상적인지 확인할 수 있다.
- 위와 같은 경우 AOF 파일이 비정상이니 fix 옵션을 사용하여 해결하라는 문구가 나왔다.

```
$ src/redis-check-aof --fix appendonlydir/appendonly.aof.manifest
Starting Checking Multi Part AOF
...
Successfully truncated AOF ppendonly.aof.15.incr.aof
All AOF files anf manifest are valid
```
- fix 옵션을 사용한 복구 또한 원본 파일을 변경한다.
#### AOF 파일의 안전성

- 운영체제에서 애플리케이션이 파일에 데이터를 저장하고자 할 때, 곧바로 디스크에 데이터가 저장되지는 않는다.
- WRITE 라는 시스템콜을 이용해 파일에 데이터를 저장하겠다 하면 커널 영역의 OS 버퍼에 임시로 저장한다.
- FSYNC는 커널의 OS 버퍼에 저장된 내용을 실제로 디스크에 내리도록 강제하는 시스템 콜이다. OS에 부하가 있더라도 FSYNC가 호출되면 데이터는 무조건 디스크에 플러시된다.
- 레디스에서 AOF 파일을 저장할 때 APPENDF SYNC 옵션을 이용하면 FSYNC 호출을 제 어할 수 있으며, 즉 파일 저장의 내구성을 제어할 수 있다. 다음과 같은 세 가지 옵션 을 사용할 수 있다.
	- APPENDFSYNC no: AOF 데이터를 저장할 때 WRITE 시스템 콜을 호출한다. 데 이터는 커널 영역에 데이터가 잘 저장되는지만 확인하기 때문에 쓰기 성능이 가 장 빠르다.
	- APPENDFSYNC always: AOF 데이터를 저장할 때 항상 WRITE와 FSYNC 시스템 콜을 함께 호출한다. 즉, 매번 쓰고자 하는 데이터가 파일에 정확하게 저장되는 것을 기다리기 때문에 쓰기 성능은 가장 느리다.
	- APPENDFSYNC everysec: 데이터를 저장할 때 WRITE 시스템 콜을 호출하며, 1초에 한 번씩 FSYNC 시스템 콜을 호출한다. 성능은 no 옵션을 사용했을 때와 거 의 비슷하다.
- 기본 옵션은 everysec로 no 옵션을 사용했을 때와 거의 비슷한 성능을가지며 유실될 수 있는 데이터가 최대 1초 이므로 균형값이다.

## 백업을 사용할 때 주의할 점

- RDB와 AOF 파일을 사용하는 경우 maxmemory 값은 실제 서버 메모리보다 여유를 갖고 설정하는 것이 좋다.
- 
